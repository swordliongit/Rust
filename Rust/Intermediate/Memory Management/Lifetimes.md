- `Non lexical lifetime` : Lifetime that is not tied to scopes
- If a function returns a reference, the reference to return has to be a parameter because returning a local reference is invalid


```rust
fn main() {
    // immutable and mutable references co-exist here because they don't overlap their scope lifetimes
    let mut vec_1 = vec![6, 5, 8, 9];
    let ref_1 = &vec_1;
    println!("ref 1: {:?}", ref_1); // Last usage of ref_1
    let ref_2 = &mut vec_1;
    ref_2.push(100);
    println!("ref 2: {:?}", ref_2); // Last usage of ref_2
}
```

# Generic Lifetimes
```rust
fn main() {
    // Compiler doesn't know if i or j will be returned and it doesn't know
    // if the references past will live enough for the returned value to be used
    // After specifying explicit lifetimes, compiler now knows that the references
    // has to live as long as the return value, so it doesn't let the int2 in this case
    // to go out of scope, because it'd be destroyed before the return value would be used,
    // that is the "picked_value"
    let int1 = 5;
    let picked_value: &i32;
    {
        let int2 = 10;
        picked_value = pick_int(&int1, &int2); // Error int2 doesn't live long enough
    }
    println!("{}", picked_value);

    fn pick_int<'a>(i: &'a i32, j: &'a i32) -> &'a i32 {
        if rand::random() {
            i
        } else {
            j
        }
    }
	// Now the lifetime of returned value to picked_value equals to int1, that lives until the end of main
    // therefore this is valid
    fn pick_int<'a>(i: &'a i32, j: &i32) -> &'a i32 {
        i
    }
}
```

# Static Lifetime &'static
```rust
fn pick_int(i: &i32, j: &i32) -> &'static i32 {
	let y: &'static i32 = &10; // static lifetime is the entire duration of the program
	y
}
```


# Lifetime Elision

1. Each parameter that is a reference, gets its own lifetime parameter.
2. If there is exactly one input lifetime parameter, that lifetime is assigned to
all output lifetime parameters.
3. If there are multiple input lifetime parameters, but one of them is &self or &mut self,
the lifetime of self is assigned to all output lifetime parameters.
4. If the rules fail, we need explicit lifetime annotation


# Examples:

```rust
// Problem 2: Identify the function signature which needs explicity lifetime parameters. 
// For those, which do not require explicit lifetimes parameters, write their expanded code which will be generated by the compiler.  

// Do not compile. This is not a program 
// Solution: 

fn print(s: &str) {}                                      // does not need explicit lifetime
fn print<'a>(s: &'a str) {}                               // expands code by compiler

fn debug(v: usize, s: &str) {}                            // does not need explicit lifetime
fn debug<'a>(v: usize, s: &'a str) {}                     // expands code by compiler

fn substr(s: &str, until: usize) -> &str {}               // does not need explicit lifetime
fn substr<'a>(s: &'a str, until: usize) -> &'a str;       // expands code by compiler

fn get_str() -> &str {}                                    // needs explicit lifetimes

fn frob(s: &str, t: &str) -> &str{}                        // needs explicit lifetimes

fn get_mut(&mut self) -> &mut T; 	                   // does not need explicit lifetime
fn get_mut<'a>(&'a mut self) -> &'a mut T;	           // expands code by compiler

fn new(buf: &mut [u8]) -> BufWriter;                       // does not need explicit lifetime
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>;            // expanded
```


# Lifetimes in Structs

1. It's quite possible that the reference becomes invalid while
the instance of the Struct is still alive.
2. Struct fields that are references to data, must have explicit lifetime specifiers.
3. Lifetime Elisions are not defined for Structs.

```rust
// The field this struct is pointing must have a lifetime as long as the struct instance has.
struct ArrayProcessor<'a> {
    data: &'a [i32],
}

/*
implicit elided lifetime not allowed here
expected lifetime parameter
*/
impl<'a> ArrayProcessor<'a> {
    fn update_data(&mut self, new_data: &'a [i32]) -> &[i32] {
        // rule 3, lifetime of self is assigned to return value, so no explicit lifetime needed
        let old_data = self.data;
        self.data = new_data; // explicit lifetime required in the type of `new_data`
        &old_data
    }
}
// Expanded to this:
impl<'a> ArrayProcessor<'a> {
    fn update_data<'b>(&'b mut self, new_data: &'a [i32]) -> &'b [i32] {
        // rule 3, lifetime of self is assigned to return value, so no explicit lifetime needed
        let old_data = self.data;
        self.data = new_data; // explicit lifetime required in the type of `new_data`
        &old_data
    }
}

fn main() {
    let mut some_data = ArrayProcessor { data: &[2, 1, 100] };

    let prev_data = some_data.update_data(&[1, 100, 1000]);
    println!("Previous data : {:?}", prev_data);
    println!("New data: {:?}", some_data.data);
}
```